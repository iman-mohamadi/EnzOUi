{
  "name": "wheel-picker",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "wheel-picker/WheelPicker.vue",
      "content": "<script setup lang=\"ts\">\nimport { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue';\n\n// --- Types ---\nexport type WheelPickerValue = string | number;\n\nexport interface WheelPickerOption<T extends WheelPickerValue = string | number> {\n  value: T;\n  label: string | number;\n}\n\nexport interface WheelPickerClassNames {\n  optionItem?: string;\n  highlightWrapper?: string;\n  highlightItem?: string;\n}\n\ninterface Props {\n  modelValue?: WheelPickerValue; // v-model\n  defaultValue?: WheelPickerValue;\n  options: WheelPickerOption[];\n  infinite?: boolean;\n  visibleCount?: number;\n  dragSensitivity?: number;\n  scrollSensitivity?: number;\n  optionItemHeight?: number;\n  classNames?: WheelPickerClassNames;\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  infinite: false,\n  visibleCount: 20,\n  dragSensitivity: 3,\n  scrollSensitivity: 5,\n  optionItemHeight: 30,\n  options: () => [],\n});\n\nconst emit = defineEmits<{\n  (e: 'update:modelValue', value: WheelPickerValue): void;\n  (e: 'change', value: WheelPickerValue): void;\n}>();\n\n// --- Constants ---\nconst RESISTANCE = 0.3;\nconst MAX_VELOCITY = 30;\n\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\nconst clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));\n\n// --- State & Refs ---\nconst containerRef = ref<HTMLElement | null>(null);\nconst wheelItemsRef = ref<HTMLElement | null>(null);\nconst highlightListRef = ref<HTMLElement | null>(null);\n\nconst internalValue = ref<WheelPickerValue>(\n    props.modelValue ?? props.defaultValue ?? props.options[0]?.value\n);\n\nconst scrollPos = ref(0);\nconst moveId = ref(0);\nconst isDragging = ref(false);\nconst lastWheelTime = ref(0);\n\nconst touchData = {\n  startY: 0,\n  yList: [] as [number, number][],\n  touchScroll: 0,\n  isClick: true,\n};\n\nlet dragController: AbortController | null = null;\n\n// --- Computed Layouts ---\nconst itemHeight = computed(() => props.optionItemHeight);\nconst halfItemHeight = computed(() => itemHeight.value * 0.5);\nconst safeVisibleCount = computed(() => Math.max(4, props.visibleCount));\nconst itemAngle = computed(() => 360 / safeVisibleCount.value);\nconst radius = computed(() => itemHeight.value / Math.tan((itemAngle.value * Math.PI) / 180));\nconst containerHeight = computed(() => Math.round(radius.value * 2 + itemHeight.value * 0.25));\nconst quarterCount = computed(() => safeVisibleCount.value >> 2);\nconst baseDeceleration = computed(() => props.dragSensitivity * 10);\nconst snapBackDeceleration = 10;\n\nconst displayOptions = computed(() => {\n  if (!props.infinite) return props.options;\n\n  const result: WheelPickerOption[] = [];\n  const halfCount = Math.ceil(safeVisibleCount.value / 2);\n\n  if (props.options.length === 0) return result;\n\n  let tempOptions = [...props.options];\n  while (result.length < halfCount) {\n    result.push(...tempOptions);\n  }\n  return result;\n});\n\nconst renderItems = computed(() => {\n  const items: Array<{\n    option: WheelPickerOption;\n    index: number;\n    angle: number;\n    key: string | number;\n    style: any\n  }> = [];\n\n  const getStyle = (angle: number) => ({\n    top: `${-halfItemHeight.value}px`,\n    height: `${itemHeight.value}px`,\n    lineHeight: `${itemHeight.value}px`,\n    transform: `rotateX(${angle}deg) translateZ(${radius.value}px)`,\n    // IMPORTANT: visibility is handled by JS updateStyles\n  });\n\n  displayOptions.value.forEach((option, index) => {\n    items.push({\n      option,\n      index,\n      angle: -itemAngle.value * index,\n      key: index,\n      style: getStyle(-itemAngle.value * index)\n    });\n  });\n\n  if (props.infinite) {\n    for (let i = 0; i < quarterCount.value; ++i) {\n      const prependIndex = -i - 1;\n      const appendIndex = i + displayOptions.value.length;\n\n      const preOption = displayOptions.value[displayOptions.value.length - i - 1];\n      items.unshift({\n        option: preOption,\n        index: prependIndex,\n        angle: itemAngle.value * (i + 1),\n        key: `pre-${i}`,\n        style: getStyle(itemAngle.value * (i + 1))\n      });\n\n      const postOption = displayOptions.value[i];\n      items.push({\n        option: postOption,\n        index: appendIndex,\n        angle: -itemAngle.value * appendIndex,\n        key: `post-${i}`,\n        style: getStyle(-itemAngle.value * appendIndex)\n      });\n    }\n  }\n\n  return items;\n});\n\nconst renderHighlightItems = computed(() => {\n  const items = displayOptions.value.map((option, index) => ({\n    option,\n    key: index\n  }));\n\n  if (props.infinite && displayOptions.value.length > 0) {\n    const firstItem = displayOptions.value[0];\n    const lastItem = displayOptions.value[displayOptions.value.length - 1];\n    items.unshift({ option: lastItem, key: 'infinite-start' });\n    items.push({ option: firstItem, key: 'infinite-end' });\n  }\n\n  return items;\n});\n\nconst wheelSegmentPositions = computed(() => {\n  let positionAlongWheel = 0;\n  const degToRad = Math.PI / 180;\n  const segmentRanges: [number, number][] = [];\n\n  for (let i = quarterCount.value - 1; i >= -quarterCount.value + 1; --i) {\n    const angle = i * itemAngle.value;\n    const segmentLength = itemHeight.value * Math.cos(angle * degToRad);\n    const start = positionAlongWheel;\n    positionAlongWheel += segmentLength;\n    segmentRanges.push([start, positionAlongWheel]);\n  }\n  return segmentRanges;\n});\n\n// --- Core Logic ---\n\nconst normalizeScroll = (scroll: number) => {\n  const length = displayOptions.value.length;\n  if (length === 0) return 0;\n  return ((scroll % length) + length) % length;\n};\n\nconst updateStyles = (scroll: number) => {\n  const normalizedScroll = props.infinite ? normalizeScroll(scroll) : scroll;\n\n  if (wheelItemsRef.value) {\n    const transform = `translateZ(${-radius.value}px) rotateX(${itemAngle.value * normalizedScroll}deg)`;\n    wheelItemsRef.value.style.transform = transform;\n\n    const children = wheelItemsRef.value.children;\n    for (let i = 0; i < children.length; i++) {\n      const li = children[i] as HTMLElement;\n      const indexStr = li.dataset.index;\n      if (indexStr !== undefined) {\n        const index = parseFloat(indexStr);\n        const distance = Math.abs(index - normalizedScroll);\n\n        // 1. Visibility Culling: Hide items far away for performance\n        const isVisible = distance <= quarterCount.value;\n        li.style.visibility = isVisible ? \"visible\" : \"hidden\";\n\n        // 2. Ghosting Fix:\n        // If the item is very close to the center (distance < 0.3),\n        // we hide the 3D version so it doesn't overlap with the Highlight version.\n        // We use opacity for a smoother transition than visibility.\n        if (isVisible) {\n          if (distance < 0.3) {\n            li.style.opacity = \"0\"; // Hide 3D item, show only Highlight item\n          } else {\n            li.style.opacity = \"1\"; // Show 3D item\n          }\n        }\n      }\n    }\n  }\n\n  if (highlightListRef.value) {\n    highlightListRef.value.style.transform = `translateY(${-normalizedScroll * itemHeight.value}px)`;\n  }\n\n  return normalizedScroll;\n};\n\nconst scrollTo = (scroll: number) => {\n  return updateStyles(scroll);\n};\n\nconst cancelAnimation = () => {\n  cancelAnimationFrame(moveId.value);\n};\n\nconst animateScroll = (\n    startScroll: number,\n    endScroll: number,\n    duration: number,\n    onComplete?: () => void\n) => {\n  if (startScroll === endScroll || duration === 0) {\n    scrollTo(startScroll);\n    return;\n  }\n\n  const startTime = performance.now();\n  const totalDistance = endScroll - startScroll;\n\n  const tick = (currentTime: number) => {\n    const elapsed = (currentTime - startTime) / 1000;\n\n    if (elapsed < duration) {\n      const progress = easeOutCubic(elapsed / duration);\n      scrollPos.value = scrollTo(startScroll + progress * totalDistance);\n      moveId.value = requestAnimationFrame(tick);\n    } else {\n      cancelAnimation();\n      scrollPos.value = scrollTo(endScroll);\n      onComplete?.();\n    }\n  };\n\n  moveId.value = requestAnimationFrame(tick);\n};\n\nconst selectByScroll = (scroll: number) => {\n  const normalized = normalizeScroll(scroll) | 0;\n  const length = displayOptions.value.length;\n  if (!length) return;\n\n  const boundedScroll = props.infinite\n      ? normalized\n      : Math.min(Math.max(normalized, 0), length - 1);\n\n  if (!props.infinite && boundedScroll !== scroll) return;\n\n  scrollPos.value = scrollTo(boundedScroll);\n\n  const selectedOption = displayOptions.value[scrollPos.value];\n  if (selectedOption) {\n    internalValue.value = selectedOption.value;\n    emit('update:modelValue', selectedOption.value);\n    emit('change', selectedOption.value);\n  }\n};\n\nconst selectByValue = (val: WheelPickerValue) => {\n  const index = displayOptions.value.findIndex((opt) => opt.value === val);\n  if (index === -1) {\n    if (displayOptions.value.length > 0) {\n      scrollPos.value = scrollTo(0);\n    }\n    return;\n  }\n  cancelAnimation();\n  scrollPos.value = scrollTo(index);\n};\n\nconst scrollByStep = (step: number) => {\n  const startScroll = scrollPos.value;\n  let endScroll = startScroll + step;\n\n  if (props.infinite) {\n    endScroll = Math.round(endScroll);\n  } else {\n    endScroll = clamp(Math.round(endScroll), 0, displayOptions.value.length - 1);\n  }\n\n  const distance = Math.abs(endScroll - startScroll);\n  if (distance === 0) return;\n\n  const duration = Math.sqrt(distance / props.scrollSensitivity);\n\n  cancelAnimation();\n  animateScroll(startScroll, endScroll, duration, () => {\n    selectByScroll(scrollPos.value);\n  });\n};\n\n// --- Input Handlers ---\n\nconst handleWheelItemClick = (clientY: number) => {\n  const container = containerRef.value;\n  if (!container) return;\n\n  const { top } = container.getBoundingClientRect();\n  const clickOffsetY = clientY - top;\n\n  const clickedSegmentIndex = wheelSegmentPositions.value.findIndex(\n      ([start, end]) => clickOffsetY >= start && clickOffsetY <= end\n  );\n\n  if (clickedSegmentIndex === -1) return;\n\n  const stepsToScroll = (quarterCount.value - clickedSegmentIndex - 1) * -1;\n  scrollByStep(stepsToScroll);\n};\n\nconst updateScrollDuringDrag = (e: MouseEvent | TouchEvent) => {\n  const currentY = (window.TouchEvent && e instanceof TouchEvent ? e.touches?.[0]?.clientY : (e as MouseEvent).clientY) || 0;\n\n  if (touchData.isClick) {\n    const dragThreshold = 5;\n    if (Math.abs(currentY - touchData.startY) > dragThreshold) {\n      touchData.isClick = false;\n    }\n  }\n\n  touchData.yList.push([currentY, Date.now()]);\n  if (touchData.yList.length > 5) touchData.yList.shift();\n\n  const dragDelta = (touchData.startY - currentY) / itemHeight.value;\n  let nextScroll = scrollPos.value + dragDelta;\n\n  if (props.infinite) {\n    nextScroll = normalizeScroll(nextScroll);\n  } else {\n    const maxIndex = displayOptions.value.length;\n    if (nextScroll < 0) nextScroll *= RESISTANCE;\n    else if (nextScroll > maxIndex) nextScroll = maxIndex + (nextScroll - maxIndex) * RESISTANCE;\n  }\n\n  touchData.touchScroll = updateStyles(nextScroll);\n};\n\nconst handleDragMoveEvent = (event: Event) => {\n  const e = event as MouseEvent | TouchEvent;\n  if (!isDragging.value && !containerRef.value?.contains(e.target as Node) && e.target !== containerRef.value) {\n    return;\n  }\n  if (e.cancelable) e.preventDefault();\n  if (displayOptions.value.length) updateScrollDuringDrag(e);\n};\n\nconst initiateDragGesture = (event: MouseEvent | TouchEvent) => {\n  isDragging.value = true;\n  dragController = new AbortController();\n  const { signal } = dragController;\n  const passiveOpts = { signal, passive: false } as AddEventListenerOptions;\n\n  containerRef.value?.addEventListener('touchmove', handleDragMoveEvent, passiveOpts);\n  document.addEventListener('mousemove', handleDragMoveEvent, passiveOpts);\n\n  const startY = (window.TouchEvent && event instanceof TouchEvent ? event.touches?.[0]?.clientY : (event as MouseEvent).clientY) || 0;\n\n  touchData.startY = startY;\n  touchData.yList = [[startY, Date.now()]];\n  touchData.touchScroll = scrollPos.value;\n  touchData.isClick = true;\n\n  cancelAnimation();\n};\n\nconst decelerateAndAnimateScroll = (initialVelocity: number) => {\n  scrollPos.value = touchData.touchScroll;\n\n  const currentScroll = scrollPos.value;\n  let targetScroll = currentScroll;\n  let deceleration = initialVelocity > 0 ? -baseDeceleration.value : baseDeceleration.value;\n  let duration = 0;\n\n  if (props.infinite) {\n    duration = Math.abs(initialVelocity / deceleration);\n    const scrollDistance = initialVelocity * duration + 0.5 * deceleration * duration * duration;\n    targetScroll = Math.round(currentScroll + scrollDistance);\n  } else if (currentScroll < 0 || currentScroll > displayOptions.value.length - 1) {\n    const target = clamp(currentScroll, 0, displayOptions.value.length - 1);\n    const scrollDistance = currentScroll - target;\n    deceleration = snapBackDeceleration;\n    duration = Math.sqrt(Math.abs(scrollDistance / deceleration));\n    initialVelocity = deceleration * duration;\n    initialVelocity = currentScroll > 0 ? -initialVelocity : initialVelocity;\n    targetScroll = target;\n  } else {\n    duration = Math.abs(initialVelocity / deceleration);\n    const scrollDistance = initialVelocity * duration + 0.5 * deceleration * duration * duration;\n    targetScroll = Math.round(currentScroll + scrollDistance);\n    targetScroll = clamp(targetScroll, 0, displayOptions.value.length - 1);\n\n    const adjustedDistance = targetScroll - currentScroll;\n    duration = Math.sqrt(Math.abs(adjustedDistance / deceleration));\n  }\n\n  animateScroll(currentScroll, targetScroll, duration, () => {\n    selectByScroll(scrollPos.value);\n  });\n\n  // Fallback sync\n  selectByScroll(scrollPos.value);\n};\n\nconst finalizeDragAndStartInertiaScroll = () => {\n  dragController?.abort();\n  dragController = null;\n  isDragging.value = false;\n\n  if (touchData.isClick) {\n    handleWheelItemClick(touchData.startY);\n    return;\n  }\n\n  const yList = touchData.yList;\n  let velocity = 0;\n\n  if (yList.length > 1) {\n    const [startY, startTime] = yList[yList.length - 2] || [0, 0];\n    const [endY, endTime] = yList[yList.length - 1] || [0, 0];\n    const timeDiff = endTime - startTime;\n    if (timeDiff > 0) {\n      const distance = startY - endY;\n      const velocityPerSecond = ((distance / itemHeight.value) * 1000) / timeDiff;\n      const direction = velocityPerSecond > 0 ? 1 : -1;\n      velocity = Math.min(Math.abs(velocityPerSecond), MAX_VELOCITY) * direction;\n    }\n  }\n\n  decelerateAndAnimateScroll(velocity);\n};\n\nconst handleDragStartEvent = (event: Event) => {\n  const e = event as MouseEvent | TouchEvent;\n  const isTargetValid = !!containerRef.value?.contains(e.target as Node) || e.target === containerRef.value;\n\n  if ((isDragging.value || isTargetValid) && e.cancelable) {\n    e.preventDefault();\n    if (displayOptions.value.length) initiateDragGesture(e);\n  }\n};\n\nconst handleDragEndEvent = (event: Event) => {\n  const e = event as MouseEvent | TouchEvent;\n  if (!displayOptions.value.length) return;\n\n  const isTargetValid = !!containerRef.value?.contains(e.target as Node) || e.target === containerRef.value;\n\n  if ((isDragging.value || isTargetValid) && e.cancelable) {\n    e.preventDefault();\n    finalizeDragAndStartInertiaScroll();\n  }\n};\n\nconst handleWheelEvent = (event: Event) => {\n  const e = event as WheelEvent;\n  if (!displayOptions.value.length || !containerRef.value) return;\n\n  const isTargetValid = containerRef.value.contains(e.target as Node) || e.target === containerRef.value;\n  if ((isDragging.value || isTargetValid) && e.cancelable) {\n    e.preventDefault();\n\n    const now = Date.now();\n    if (now - lastWheelTime.value < 100) return;\n\n    const direction = Math.sign(e.deltaY);\n    if (!direction) return;\n\n    lastWheelTime.value = now;\n    scrollByStep(direction);\n  }\n};\n\n// --- Lifecycle & Watchers ---\n\nwatch(() => props.modelValue, (newVal) => {\n  if (newVal !== undefined && newVal !== internalValue.value) {\n    internalValue.value = newVal;\n    selectByValue(newVal);\n  }\n});\n\nwatch(() => props.options, () => {\n  nextTick(() => {\n    selectByValue(internalValue.value);\n  });\n}, { deep: true });\n\nonMounted(() => {\n  const container = containerRef.value;\n  if (!container) return;\n\n  const opts = { passive: false };\n  container.addEventListener(\"touchstart\", handleDragStartEvent, opts);\n  container.addEventListener(\"touchend\", handleDragEndEvent, opts);\n  container.addEventListener(\"wheel\", handleWheelEvent, opts);\n  document.addEventListener(\"mousedown\", handleDragStartEvent, opts);\n  document.addEventListener(\"mouseup\", handleDragEndEvent, opts);\n\n  // Initial selection\n  nextTick(() => {\n    selectByValue(internalValue.value);\n  });\n});\n\nonUnmounted(() => {\n  const container = containerRef.value;\n  if (container) {\n    container.removeEventListener(\"touchstart\", handleDragStartEvent);\n    container.removeEventListener(\"touchend\", handleDragEndEvent);\n    container.removeEventListener(\"wheel\", handleWheelEvent);\n  }\n  document.removeEventListener(\"mousedown\", handleDragStartEvent);\n  document.removeEventListener(\"mouseup\", handleDragEndEvent);\n  dragController?.abort();\n  cancelAnimation();\n});\n</script>\n\n<template>\n  <div\n      ref=\"containerRef\"\n      class=\"rwp-wrapper\"\n      :class=\"classNames?.highlightWrapper\"\n      :style=\"{ height: `${containerHeight}px` }\"\n      tabindex=\"0\"\n      role=\"listbox\"\n      :aria-label=\"'Choose an option'\"\n  >\n    <!-- 3D Wheel Items -->\n    <ul ref=\"wheelItemsRef\" class=\"rwp-options\">\n      <li\n          v-for=\"item in renderItems\"\n          :key=\"item.key\"\n          :data-index=\"item.index\"\n          class=\"rwp-option-item\"\n          :class=\"classNames?.optionItem\"\n          :style=\"item.style\"\n      >\n        {{ item.option.label }}\n      </li>\n    </ul>\n\n    <!-- Center Highlight Overlay -->\n    <div\n        class=\"rwp-highlight-wrapper\"\n        :style=\"{ height: `${itemHeight}px`, lineHeight: `${itemHeight}px` }\"\n    >\n      <ul\n          ref=\"highlightListRef\"\n          class=\"rwp-highlight-list\"\n          :style=\"{ top: infinite ? `${-itemHeight}px` : undefined }\"\n      >\n        <li\n            v-for=\"item in renderHighlightItems\"\n            :key=\"item.key\"\n            class=\"rwp-highlight-item\"\n            :class=\"classNames?.highlightItem\"\n            :style=\"{ height: `${itemHeight}px` }\"\n        >\n          {{ item.option.label }}\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n/* Reset & Base */\nul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\n\nli {\n  margin: 0;\n  padding: 0;\n}\n\n.rwp-wrapper {\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  width: 100%;\n  align-items: stretch;\n  justify-content: space-between;\n  perspective: 2000px;\n  user-select: none;\n  /* Mask Image for fade effect - keeps 3D look */\n  mask-image: linear-gradient(\n      to bottom,\n      transparent 0%,\n      black 20%,\n      black 80%,\n      transparent 100%\n  );\n  -webkit-mask-image: linear-gradient(\n      to bottom,\n      transparent 0%,\n      black 20%,\n      black 80%,\n      transparent 100%\n  );\n  cursor: grab;\n}\n\n.rwp-wrapper:active {\n  cursor: grabbing;\n}\n\n/* Center Highlight Bar */\n.rwp-highlight-wrapper {\n  position: absolute;\n  overflow: hidden;\n  top: 50%;\n  width: 100%;\n  transform: translateY(-50%);\n  font-size: 1rem;\n  font-weight: 500;\n  pointer-events: none;\n  /* Use alpha border for dark mode compatibility */\n  border-top: 1px solid rgba(128,128,128,0.2);\n  border-bottom: 1px solid rgba(128,128,128,0.2);\n}\n\n.rwp-highlight-list {\n  position: absolute;\n  width: 100%;\n  left: 0;\n}\n\n/* 3D Rotating List */\n.rwp-options {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  display: block;\n  width: 100%;\n  height: 0;\n  margin: 0 auto;\n  -webkit-font-smoothing: subpixel-antialiased;\n  will-change: transform;\n  backface-visibility: hidden;\n  transform-style: preserve-3d;\n}\n\n.rwp-option-item {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  -webkit-font-smoothing: subpixel-antialiased;\n  will-change: visibility;\n  font-size: 0.875rem;\n  /* Safer color for unselected items in dark mode */\n  color: #888;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* Transition opacity for smoother ghosting fix */\n  transition: opacity 0.1s linear;\n}\n\n.rwp-highlight-item {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* Adapts to parent color (Dark Mode friendly) */\n  color: currentColor;\n}\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerWrapper.vue",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils';\n\ndefineProps<{\n  class?: string;\n}>();\n</script>\n\n<template>\n  <div :class=\"cn($props.class)\" data-rwp-wrapper>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n/* Exact CSS from React source */\n[data-rwp-wrapper] {\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  width: 100%;\n  align-items: stretch;\n  justify-content: space-between;\n  perspective: 2000px; /* <--- THIS FIXES THE VISUAL GLITCH */\n  user-select: none;\n}\n\n:deep([data-rwp-wrapper] ul) {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\n\n:deep([data-rwp-wrapper] li) {\n  margin: 0;\n  padding: 0;\n}\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/index.ts",
      "content": "export { default as WheelPicker } from './WheelPicker.vue'\nexport { default as WheelPickerWrapper } from './WheelPickerWrapper.vue'\nexport type { WheelPickerOption } from './WheelPicker.vue'\n",
      "type": "registry:ui"
    }
  ]
}