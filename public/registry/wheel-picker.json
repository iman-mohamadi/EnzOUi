{
  "name": "wheel-picker",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "wheel-picker/WheelPicker.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\nimport { ref, computed, onMounted, onUnmounted, watch, nextTick, provide } from 'vue';\nimport { cn } from '@/lib/utils';\n\nexport interface WheelPickerOption<T = string | number> {\n  value: T;\n  label: string;\n}\n\nconst props = withDefaults(defineProps<{\n  modelValue?: T;\n  defaultValue?: T;\n  options?: WheelPickerOption<T>[];\n  infinite?: boolean;\n  visibleCount?: number;\n  dragSensitivity?: number;\n  scrollSensitivity?: number;\n  itemHeight?: number;\n  class?: string;\n  overlayClass?: string;\n}>(), {\n  options: () => [],\n  infinite: false,\n  visibleCount: 20,\n  dragSensitivity: 3,\n  scrollSensitivity: 5,\n  itemHeight: 30,\n});\n\nconst emit = defineEmits<{\n  (e: 'update:modelValue', value: T): void;\n}>();\n\n// --- 1. Option Gathering ---\nconst childOptions = ref<WheelPickerOption<T>[]>([]);\nprovide('wheel-picker-register', (option: WheelPickerOption<T>) => {\n  childOptions.value.push(option);\n});\n\nconst optionsProp = computed(() => (props.options && props.options.length > 0) ? props.options : childOptions.value);\n\n// --- 2. Enhanced Data Padding ---\nconst options = computed(() => {\n  if (!props.infinite) return optionsProp.value;\n\n  const result = [];\n  // FIX: React used 'halfCount' but that leaves gaps for lists like Hours (12 items vs 20 slots).\n  // We use 'visibleCount' to ensure the cylinder is fully populated for smooth rotation.\n  const paddingCount = props.visibleCount;\n\n  if (optionsProp.value.length === 0) return result;\n\n  // Clone options until we have enough to fill the cylinder\n  while (result.length < paddingCount) {\n    result.push(...optionsProp.value);\n  }\n  // Ensure we add one more batch to allow safe wrapping\n  result.push(...optionsProp.value);\n\n  return result;\n});\n\n// --- 3. Measurements ---\nconst measurements = computed(() => {\n  const count = props.visibleCount;\n  const height = props.itemHeight;\n  const itemAngle = 360 / count;\n  const radius = height / Math.tan((itemAngle * Math.PI) / 180);\n  const containerHeight = Math.round(radius * 2 + height * 0.25);\n  const quarterCount = count >> 2;\n\n  return { height, halfItemHeight: height * 0.5, itemAngle, radius, containerHeight, quarterCount };\n});\n\n// --- 4. Visual Padding ---\nconst displayItems = computed(() => {\n  const { itemAngle, quarterCount } = measurements.value;\n  const src = options.value;\n\n  const items = src.map((item, index) => ({\n    ...item,\n    _index: index,\n    angle: -itemAngle * index\n  }));\n\n  if (props.infinite && src.length > 0) {\n    for (let i = 0; i < quarterCount; ++i) {\n      const prependIndex = -i - 1;\n      items.unshift({\n        ...src[src.length - 1 - (i % src.length)],\n        _index: prependIndex,\n        angle: itemAngle * (i + 1)\n      });\n      const appendIndex = i + src.length;\n      items.push({\n        ...src[i % src.length],\n        _index: appendIndex,\n        angle: -itemAngle * appendIndex\n      });\n    }\n  }\n  return items;\n});\n\nconst highlightItems = computed(() => {\n  const src = options.value;\n  const items = src.map((item, i) => ({ ...item, key: i }));\n  if (props.infinite && src.length > 0) {\n    items.unshift({ ...src[src.length - 1], key: 'start-inf' as any });\n    items.push({ ...src[0], key: 'end-inf' as any });\n  }\n  return items;\n});\n\nconst wheelSegmentPositions = computed(() => {\n  const { quarterCount, itemAngle, height } = measurements.value;\n  let pos = 0;\n  const segments: [number, number][] = [];\n  for (let i = quarterCount - 1; i >= -quarterCount + 1; --i) {\n    const len = height * Math.cos(i * itemAngle * (Math.PI / 180));\n    segments.push([pos, pos + len]);\n    pos += len;\n  }\n  return segments;\n});\n\n// --- 5. Physics State ---\nconst containerRef = ref<HTMLElement | null>(null);\nconst wheelItemsRef = ref<HTMLElement | null>(null);\nconst highlightListRef = ref<HTMLElement | null>(null);\nconst localValue = ref<T>(props.modelValue ?? props.defaultValue ?? (optionsProp.value[0]?.value as T));\n\nlet scrollRef = 0;\nlet moveId = 0;\nlet isDragging = false;\nlet lastWheelTime = 0;\nlet dragController: AbortController | null = null;\nconst touchData = { startY: 0, yList: [] as [number, number][], touchScroll: 0, isClick: true };\n\n// --- 6. Core Logic ---\nconst RESISTANCE = 0.3;\nconst MAX_VELOCITY = 30;\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\nconst clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(v, max));\n\nconst normalizeScroll = (scroll: number) => {\n  const len = options.value.length;\n  if (len === 0) return 0;\n  return ((scroll % len) + len) % len;\n};\n\nconst scrollTo = (scroll: number) => {\n  const { radius, itemAngle, quarterCount, height } = measurements.value;\n  const normalizedScroll = props.infinite ? normalizeScroll(scroll) : scroll;\n\n  if (wheelItemsRef.value) {\n    wheelItemsRef.value.style.transform = `translateZ(${-radius}px) rotateX(${itemAngle * normalizedScroll}deg)`;\n\n    // Manual DOM Visibility (Performance optimized)\n    const children = wheelItemsRef.value.children;\n    for (let i = 0; i < children.length; i++) {\n      const li = children[i] as HTMLElement;\n      // Safety check for dataset\n      if (!li.dataset.index) continue;\n\n      const idx = parseFloat(li.dataset.index);\n      const distance = Math.abs(idx - normalizedScroll);\n\n      // We manually toggle visibility.\n      // Because we moved 'visibility: hidden' to CSS class, Vue won't fight us here.\n      if (distance > quarterCount) {\n        li.style.visibility = \"hidden\";\n      } else {\n        li.style.visibility = \"visible\";\n      }\n    }\n  }\n\n  if (highlightListRef.value) {\n    highlightListRef.value.style.transform = `translateY(${-normalizedScroll * height}px)`;\n  }\n\n  return normalizedScroll;\n};\n\nconst cancelAnimation = () => cancelAnimationFrame(moveId);\n\nconst animateScroll = (start: number, end: number, duration: number, onComplete?: () => void) => {\n  if (start === end || duration === 0) {\n    scrollTo(start);\n    return;\n  }\n  const startTime = performance.now();\n  const dist = end - start;\n\n  const tick = (now: number) => {\n    const elapsed = (now - startTime) / 1000;\n    if (elapsed < duration) {\n      scrollRef = scrollTo(start + easeOutCubic(elapsed / duration) * dist);\n      moveId = requestAnimationFrame(tick);\n    } else {\n      cancelAnimation();\n      scrollRef = scrollTo(end);\n      onComplete?.();\n    }\n  };\n  requestAnimationFrame(tick);\n};\n\nconst selectByScroll = (scroll: number) => {\n  const opts = options.value;\n  if (!opts.length) return;\n  const norm = normalizeScroll(scroll) | 0;\n  const bounded = props.infinite ? norm : Math.min(Math.max(norm, 0), opts.length - 1);\n\n  if (!props.infinite && bounded !== scroll) return;\n\n  scrollRef = scrollTo(bounded);\n  const selected = opts[scrollRef];\n  if (selected && selected.value !== localValue.value) {\n    localValue.value = selected.value;\n    emit('update:modelValue', selected.value);\n  }\n};\n\nconst selectByValue = (val: T) => {\n  const idx = options.value.findIndex(o => o.value === val);\n  if (idx !== -1) {\n    cancelAnimation();\n    selectByScroll(idx);\n  }\n};\n\n// --- 7. Interactions ---\nconst scrollByStep = (step: number) => {\n  const start = scrollRef;\n  let end = start + step;\n  if (props.infinite) end = Math.round(end);\n  else end = clamp(Math.round(end), 0, options.value.length - 1);\n\n  const dist = Math.abs(end - start);\n  if (dist === 0) return;\n\n  const duration = Math.sqrt(dist / props.scrollSensitivity);\n  cancelAnimation();\n  animateScroll(start, end, duration, () => selectByScroll(scrollRef));\n};\n\nconst updateScrollDuringDrag = (e: MouseEvent | TouchEvent) => {\n  const y = (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\n  const { startY, yList } = touchData;\n  if (touchData.isClick && Math.abs(y - startY) > 5) touchData.isClick = false;\n  touchData.yList.push([y, Date.now()]);\n  if (touchData.yList.length > 5) touchData.yList.shift();\n\n  const delta = (startY - y) / props.itemHeight;\n  let next = scrollRef + delta;\n\n  if (props.infinite) next = normalizeScroll(next);\n  else {\n    const max = options.value.length;\n    if (next < 0) next *= RESISTANCE;\n    else if (next > max) next = max + (next - max) * RESISTANCE;\n  }\n  touchData.touchScroll = scrollTo(next);\n};\n\nconst handleDragStart = (e: MouseEvent | TouchEvent) => {\n  const isTarget = !!containerRef.value?.contains(e.target as Node) || e.target === containerRef.value;\n  if (!isTarget && !isDragging) return;\n  if (e.cancelable) e.preventDefault();\n\n  isDragging = true;\n  dragController = new AbortController();\n  const { signal } = dragController;\n\n  const y = (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\n  touchData.startY = y;\n  touchData.yList = [[y, Date.now()]];\n  touchData.touchScroll = scrollRef;\n  touchData.isClick = true;\n\n  cancelAnimation();\n\n  const opts = { signal, passive: false };\n  const onMove = (ev: MouseEvent | TouchEvent) => { if(ev.cancelable) ev.preventDefault(); updateScrollDuringDrag(ev); };\n  document.addEventListener('mousemove', onMove, opts);\n  document.addEventListener('touchmove', onMove, opts);\n\n  const onEnd = (ev: MouseEvent | TouchEvent) => {\n    if(ev.cancelable) ev.preventDefault();\n    dragController?.abort();\n    dragController = null;\n    isDragging = false;\n\n    if (touchData.isClick) {\n      handleWheelItemClick(touchData.startY);\n      return;\n    }\n\n    let vel = 0;\n    const { yList } = touchData;\n    if (yList.length > 1) {\n      const last = yList[yList.length - 1];\n      const prev = yList[yList.length - 2];\n      const timeDiff = last[1] - prev[1];\n      if (timeDiff > 0) {\n        const dist = prev[0] - last[0];\n        const v = ((dist / props.itemHeight) * 1000) / timeDiff;\n        vel = Math.min(Math.abs(v), MAX_VELOCITY) * Math.sign(v);\n      }\n    }\n    scrollRef = touchData.touchScroll;\n    decelerateAndAnimateScroll(vel);\n  };\n\n  document.addEventListener('mouseup', onEnd, opts);\n  document.addEventListener('touchend', onEnd, opts);\n};\n\nconst handleWheelItemClick = (clientY: number) => {\n  if (!containerRef.value) return;\n  const { top } = containerRef.value.getBoundingClientRect();\n  const offset = clientY - top;\n  const idx = wheelSegmentPositions.value.findIndex(([s, e]) => offset >= s && offset <= e);\n  if (idx !== -1) {\n    const steps = (measurements.value.quarterCount - idx - 1) * -1;\n    scrollByStep(steps);\n  }\n};\n\nconst decelerateAndAnimateScroll = (velocity: number) => {\n  const start = scrollRef;\n  const len = options.value.length;\n  const decel = props.dragSensitivity * 10;\n  let end = start;\n  let duration = 0;\n\n  if (props.infinite) {\n    duration = Math.abs(velocity / decel);\n    const dist = velocity * duration + 0.5 * (velocity > 0 ? -decel : decel) * duration ** 2;\n    end = Math.round(start + dist);\n  } else {\n    if (start < 0 || start > len - 1) {\n      end = clamp(start, 0, len - 1);\n      duration = Math.sqrt(Math.abs(start - end) / 10);\n    } else {\n      duration = Math.abs(velocity / decel);\n      const dist = velocity * duration + 0.5 * (velocity > 0 ? -decel : decel) * duration ** 2;\n      end = Math.round(start + dist);\n      end = clamp(end, 0, len - 1);\n      duration = Math.sqrt(Math.abs(end - start) / decel);\n    }\n  }\n  animateScroll(start, end, duration, () => selectByScroll(scrollRef));\n};\n\nconst handleWheel = (e: WheelEvent) => {\n  if(!containerRef.value?.contains(e.target as Node)) return;\n  e.preventDefault();\n  if (Date.now() - lastWheelTime < 100) return;\n  lastWheelTime = Date.now();\n  scrollByStep(Math.sign(e.deltaY));\n};\n\nwatch(() => props.modelValue, (v) => { if(v !== undefined && v !== localValue.value) { localValue.value = v; selectByValue(v); }});\n\nonMounted(() => {\n  nextTick(() => selectByValue(localValue.value));\n  const el = containerRef.value;\n  if(el) {\n    el.addEventListener('mousedown', handleDragStart, { passive: false });\n    el.addEventListener('touchstart', handleDragStart, { passive: false });\n    el.addEventListener('wheel', handleWheel, { passive: false });\n  }\n});\n\nonUnmounted(() => {\n  const el = containerRef.value;\n  if(el) {\n    el.removeEventListener('mousedown', handleDragStart);\n    el.removeEventListener('touchstart', handleDragStart);\n    el.removeEventListener('wheel', handleWheel);\n  }\n});\n</script>\n\n<template>\n  <div ref=\"containerRef\" :class=\"cn($props.class)\" :style=\"{ height: `${measurements.containerHeight}px` }\" data-rwp>\n    <slot />\n    <ul ref=\"wheelItemsRef\" data-rwp-options>\n      <li\n          v-for=\"item in displayItems\"\n          :key=\"`${item._index}-${item.value}`\"\n          :data-index=\"item._index\"\n          data-rwp-option\n          :style=\"{\n          top: `${-measurements.halfItemHeight}px`,\n          height: `${measurements.height}px`,\n          lineHeight: `${measurements.height}px`,\n          transform: `rotateX(${item.angle}deg) translateZ(${measurements.radius}px)`,\n        }\"\n      >\n        {{ item.label }}\n      </li>\n    </ul>\n\n    <div\n        :class=\"cn(props.overlayClass)\"\n        data-rwp-highlight-wrapper\n        :style=\"{ height: `${measurements.height}px`, lineHeight: `${measurements.height}px` }\"\n    >\n      <ul ref=\"highlightListRef\" data-rwp-highlight-list :style=\"{ top: props.infinite ? `-${measurements.height}px` : undefined }\">\n        <li\n            v-for=\"item in highlightItems\"\n            :key=\"`${item.key}`\"\n            data-rwp-highlight-item\n            :style=\"{ height: `${measurements.height}px` }\"\n        >\n          {{ item.label }}\n        </li>\n      </ul>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n/* CSS copied exactly from React style.css */\n[data-rwp] {\n  position: relative;\n  overflow: hidden;\n  flex: 1;\n  cursor: default;\n  mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\n  -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);\n}\n\n[data-rwp-highlight-wrapper] {\n  position: absolute;\n  overflow: hidden;\n  top: 50%;\n  width: 100%;\n  transform: translateY(-50%);\n  font-size: 1rem;\n  font-weight: 500;\n  pointer-events: none;\n}\n\n[data-rwp-highlight-list] {\n  position: absolute;\n  width: 100%;\n}\n\n[data-rwp-options] {\n  position: absolute;\n  top: 50%;\n  left: 0;\n  display: block;\n  width: 100%;\n  height: 0;\n  margin: 0 auto;\n  -webkit-font-smoothing: subpixel-antialiased;\n  will-change: transform;\n  backface-visibility: hidden;\n  transform-style: preserve-3d;\n}\n\n[data-rwp-option] {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  -webkit-font-smoothing: subpixel-antialiased;\n  /* FIX: Default state is hidden in CSS, so Vue doesn't override it. JS toggles it to visible. */\n  visibility: hidden;\n  will-change: visibility;\n  font-size: 0.875rem;\n}\n\n[data-rwp-option], [data-rwp-highlight-item] {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerItem.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends string | number\">\nimport { inject, onMounted } from 'vue';\nimport type { WheelPickerOption } from './WheelPicker.vue';\n\nconst props = defineProps<{ value: T; label?: string; }>();\nconst register = inject<(option: WheelPickerOption<T>) => void>('wheel-picker-register');\n\nonMounted(() => {\n  if (register) register({ value: props.value, label: props.label ?? String(props.value) });\n});\n</script>\n<template><span style=\"display: none;\"></span></template>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerWrapper.vue",
      "content": "<script setup lang=\"ts\">\nimport { cn } from '@/lib/utils';\n\ndefineProps<{\n  class?: string;\n}>();\n</script>\n\n<template>\n  <div :class=\"cn($props.class)\" data-rwp-wrapper>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n/* Exact CSS from React source */\n[data-rwp-wrapper] {\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  width: 100%;\n  align-items: stretch;\n  justify-content: space-between;\n  perspective: 2000px; /* <--- THIS FIXES THE VISUAL GLITCH */\n  user-select: none;\n}\n\n:deep([data-rwp-wrapper] ul) {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\n\n:deep([data-rwp-wrapper] li) {\n  margin: 0;\n  padding: 0;\n}\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/index.ts",
      "content": "export { default as WheelPicker } from './WheelPicker.vue'\nexport { default as WheelPickerItem } from './WheelPickerItem.vue'\nexport { default as WheelPickerWrapper } from './WheelPickerWrapper.vue'\nexport type { WheelPickerOption } from './WheelPicker.vue'\n",
      "type": "registry:ui"
    }
  ]
}